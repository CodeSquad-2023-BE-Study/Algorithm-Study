
### 이진탐색
https://www.acmicpc.net/blog/view/109
- 이분 탐색이란 결정 문제의 답이 이분적일 떄 사용할 수 있는 탐색 기법
  - 이분적이다? : 결정 문제의 답이 두 구간으로 나뉘는 것. 이 경우, 이분탐색을 통해 경계를 찾을 수 있다.
  - 경계 : [lo,hi] 구간을 잡은 뒤 Check(lo) != Check(hi)가 되어야한다. -> 답이 바뀌는 경계를 포함함을 의미
- 시간 복잡도 avg : O(logn) worst : O(logn)이다.

### 이진탐색 구현방법
- Check(lo) != Check(hi)가 되도록 lo, hi의 초기값 설정, lo + 1 < hi인 동안 Check(lo) == Check(mid)라면 lo = mid를, Check(hi) == Check(mid)라면 hi = mid를 해주면 됩니다.

### 자주하는 실수
자주하는 실수 모음
1. lo, hi는 항상 정답의 범위를 나타낼 수 있도록 해야합니다. 예를 들어 lo를 출력해야 하는 문제의 답이 최대 n일 때 hi = n으로 선언하거나, hi를 출력해야 하는 문제의 답이 최소 0일 때 lo = 0으로 선언하면 안됩니다. (hi = n + 1, lo = -1로 선언해야 합니다)
- Low와
2. 오버플로우에 주의해야 합니다. 이분 탐색을 사용하는 문제는 대부분 수의 범위가 크기 때문에 오버플로우가 발생할 수 있습니다.
> 이번 문제에서도 발생, 부동소수점에 따른 오차를 반영한 테케도 존재해서, BigInteger 클래스를 이용해서 해결했다.
3. 결정 문제의 정의에 맞게 Check함수를 잘 구현해야 합니다. 예를 들어 lower_bound는 v[i] >= k인 i의 최솟값을 구하는 함수이고, upper_bound는 v[i] > k인 i의 최솟값을 구하는 함수인데, Check 함수의 부등호를 조금만 틀려도 전혀 엉뚱한 값이 튀어나올 수 있습니다.

### 정수 제곱근 풀이

- 접근
정수의 범위가 0부터 2^63이므로 n의 범위는 약 10^18로 O(n)의 시간 복잡도로는 해결할 수 없다.
- 따라서 O(log n)이하의 시간 복잡도 알고리즘으로 해결해야하는데, 대표적인 것이 이진탐색이다.
- 0부터 2의 63은 long의 범위이다. 따라서 long으로 모든 범위를 표현할 수 있다.

### 수 찾기

- 접근
브루트포스로 접근 시 O(n2)으로 100000*100000 = 100억으로 O(nlogn)이하의 시간복잡도로 구현해야한다.
- 이분탐색으로 구현 시 정렬이 필요하다. 정렬 후 이분 탐색 실행 : O(nlogn)으로 구현 가능
- Check 함수의 설정 : 같거나 작은 함수를 탐색하여 같거나 작은 경우(low)의 최대 값과 key값이 같은 경우에만 해가 존재한다.
- 범위 설정 : low로 탐색하는 경우에는 high를 n+1로 설정해야 low가 n까지 탐색할 수 있다.

### 게임

- 접근
1게임씩 더하면서 승률을 갱신하는 경우 O(n)이다. X의 범위는 10억이므로 worst case 시간초과가 발생 가능하다.
따라서 1게임씩 더하면서 갱신하는 것이 아닌 다음게임부터 이분탐색으로 승률이 바뀌는 지점을 탐색하기로 한다.
- 배열 : 예를 들어 승률이 80, 80, 80, 81, 81 ...를 이분탐색으로 변환하면 T T T F F F F...가 된다. 
- Check 함수의 설정 : 승률이 같다.
- 범위 설정 : high로 탐색하여 lower bound를 찾아낸다.

- lower_bound, upper_bound
- 이분 탐색이 사용되는 대표적인 예시, 배열에서 특정 값 이상 또는 초과인 원소가 처음 등장하는 위치를 찾는 문제.

### 용돈 관리

- 접근
- 반복문으로 brute force하는 경우 10000*100000=10억으로 시간초과 발생
- 금액을 탐색하는 경우를 이진탐색하는 경우 log(10000)*100000으로 감소

### 나무자르기
- 접근
- M미터의 나무를 자르기 위해 필요한 높이의 최대값
- M에 대해서 탐색해야하나, 20억이므로 이진탐색으로 구현할 수 있다.
